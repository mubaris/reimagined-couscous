pragma solidity ^0.6.0;

import "@openzeppelin/contracts/math/SafeMath.sol";

interface TokenInterface {
    function approve(address, uint256) external;
    function transfer(address, uint) external;
    function transferFrom(address, address, uint) external;
    function deposit() external payable;
    function withdraw(uint) external;
    function balanceOf(address) external view returns (uint);
    function decimals() external view returns (uint);
}

interface IUniswapV2Router02 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Factory {
  function getPair(address tokenA, address tokenB) external view returns (address pair);
  function allPairs(uint) external view returns (address pair);
  function allPairsLength() external view returns (uint);

  function feeTo() external view returns (address);
  function feeToSetter() external view returns (address);

  function createPair(address tokenA, address tokenB) external returns (address pair);
}

contract Serene {
    using SafeMath for uint;

    function getAddressWETH() internal pure returns (address) {
        return 0xc778417E063141139Fce010982780140Aa0cD5Ab;
    }

    function getUniswapAddr() internal pure returns (address) {
        return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    }

    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {
        amt = (_amt / 10 ** (18 - _dec));
    }

    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {
        amt = mul(_amt, 10 ** (18 - _dec));
    }

    function _addLiquidity(
        address tokenA,
        address tokenB,
        uint amtA,
        uint amtB,
        uint minAmtA
        uint minAmtB
    ) internal returns (uint _amtA, uint _amtB, uint _liquidity) {
        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());

        (_amtA, _amtB, _liquidity) = router.addLiquidity(
            tokenA,
            tokenB,
            amtA,
            amtB,
            minAmtA,
            minAmtB,
            msg.sender,
            now + 5
        );
    }

    function _removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint minAmtA
        uint minAmtB
    ) internal returns (uint _amtA, uint _amtB) {
        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());

        (_amtA, _amtB) = router.removeLiquidity(
            tokenA,
            tokenB,
            liquidity,
            minAmtA,
            minAmtB,
            msg.sender,
            now + 5
        );
    }
}
